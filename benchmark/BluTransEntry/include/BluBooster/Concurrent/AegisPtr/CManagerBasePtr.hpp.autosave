#ifndef CMANAGERBASEPTR_HPP
#define CMANAGERBASEPTR_HPP
#include <array>
#include <stdint.h>
#include <BluBooster/CPU/CPU.hpp>
#include <BluBooster/SharedObjects.hpp>
#include <BluBooster/Macros.hpp>

namespace BluBooster::Concurrent::CSharedPtr::Internal::SIMD {
    template <size_t MAX_THREADS>
BLUBOOSTER_FORCE_INLINE bool CanDestroy(std::array<uint8_t,MAX_THREADS>& flags) {
        size_t leftOver = MAX_THREADS;
        size_t i = 0;
        if constexpr(BluBooster::CPU::hasAVX512) {
            while (BluBooster::cpuFeatures.hasAVX512F && leftOver >= 64) {
                __m512i chunk = _mm512_loadu_si512(reinterpret_cast<__m512i*>(&flags[i]));
                __mmask64 mask = _mm512_test_epi8_mask(chunk,_mm512_setzero_si512());
                if(mask != 0) return false;
                leftOver = MAX_THREADS - i;
            }
        }
        if constexpr(BluBooster::CPU::hasAVX2) {
            while(BluBooster::cpuFeatures.hasAVX2 && leftOver >= 32) {
                __m256i chunk = _mm256_loadu_si256(reinterpret_cast<__m256i*>(&flags[i]));
                __m256i cnt = _mm256_cmpeq_epi8(chunk,_mm256_setzero_si256());
                int mask = _mm256_movemask_epi8(cnt);
                if(mask != 0xFFFFFFFF) return false;
                leftOver = MAX_THREADS - i;
                i += 32;
            }
        }
        if constexpr(BluBooster::CPU::hasSSE42) {
            while(BluBooster::cpuFeatures.hasSSE42 && leftOver >= 16) {
                __m128i chunk = _mm_loadu_si128(reinterpret_cast<__m128i*>(&flags[i]));
                __m128i cmp = _mm_cmpeq_epi8(chunk,_mm_setzero_si128());
                int mask = _mm_movemask_epi8(cmp);
                if(mask != 0xFFFF) return false;
                i += 16;
            }
        }
        for(; i < MAX_THREADS; ++i)
            if(flags[i] != 0) return false;
        return true;
    }

}
namespace BluBooster::Concurrent::CSharedPtr::Internal{
    template <typename T,size_t MAX_THREADS>
    struct alignas(64) AegisPtrBaseHolderSlot{
        T* ptr{nullptr};
        std::array<uint8_t,MAX_THREADS> flags{};
    };

    template <typename T, size_t N>
    struct AegisPtrBaseHolder;

    template <typename U>
    struct is_aegis_ptr_base_holder : std::false_type{};

    template <typename U,size_t N>
    struct is_aegis_ptr_base_holder <AegisPtrBaseHolder<U,N>> : std::true_type{};

    template <typename U>
    inline constexpr bool is_aegis_ptr_base_holder_v = is_cmanager_base_ptr<std::remove_cv_t<U>>::value;
    template <typename T,size_t MAX_THREADS = 16>
    struct CManagerBasePtr{
        static_assert(!is_cmanager_base_ptr_v<T>,"T must not be itself CManagerBasePtr.");
        static_assert(MAX_THREADS % 8 == 0,"Threads Must be divided by 8. ");
        CManagerBasePtr() = delete;
        CManagerBasePtr(const T& _rawData) {
            m_base.ptr = BluBooster::Alloc<T>(_rawData);
        }
        CManagerBasePtr(T&& _mvRawData) {
            m_base.ptr = BluBooster::Alloc<T>(std::move(_mvRawData));
        }
        CManagerBasePtr(const CManagerBasePtr<T,MAX_THREADS>& other) = delete;
        CManagerBasePtr<T,MAX_THREADS>& operator= (const CManagerBasePtr<T,MAX_THREADS>& other) = delete;
        CManagerBasePtr(CManagerBasePtr<T,MAX_THREADS>&& other) = delete;
        CManagerBasePtr& operator=(CManagerBasePtr<T,MAX_THREADS>&& other) = delete;
        
        ~CManagerBasePtr() {
            if(SIMD::CanDestroy(m_base.flags))
                BluBooster::Memory::SystemAllocator::Free(m_base.ptr);
        }
        CManagerBasePtrSlot<T,MAX_THREADS> m_base{};
    };
}

#endif // CMANAGERBASEPTR_HPP
